# laba5
# Задача
Реализовать возможность "выполнения" спорта различными способами: соревнования целиком ("swallow"), соревнования по частям ("bite off") или предварительно разрезделив на отдельные дни ("chop"). Возможно, перечень способов будет расширяться. Изменять интерфейс существующих функций класса нельзя! (потому что написано много кода, который использует существующий интерфейс)

# Решение с использованием паттерна "Стратегия"
Объявить перечисляемый тип способа выполнения.
Создать класс абстрактный класс стратегии выполнения SportStrategy
Унаследовать от него конкретные классы стратегий: SwallowSportStrategy, BiteOffSportStrategy, ChopSportStrategy
Разработать фабричный метод для создания экземпляров классов стратегий выполнения.
Инкапсулировать стратегию выполнения в родительском классе Sport с использованием указателя.
Дополнить интерфейс класса Sport функцией для задания стратегии SetSportManner(SportMannerEnum).
Переписать функцию Competition() родительского класса Sport, чтобы она использовала указанную стратегию.
# Краткая характеристика паттерна "Стратегия"
Паттерн "Стратегия" определяет семейство алгоритмов, инкапсулирует каждый из них и обеспечивает их взаимозаменяемость. Он позволяет модифицировать алгоритмы независимо от их использования на стороне клиента.

# Решение с использованием паттерна "Шаблонный метод"
# Задача
Унифицировать структуру алгоритма метода Competition() родительского класса Sport и унаследованных от него классов.
Уменьшить количество дублируемого кода в методах Competition().
Решение с использованием паттерна "Шаблонный метод"
Зафиксировать общую структуру алгоритма на уровне родительского класса, создав соответствующие абстрактные методы-этапы алгоритма. Функция Competition() перестает быть виртуальной!
Весь повторяющийся код реализовать на уровне родительского класса.
Весь специфический для конкретного спорта код перенести в реализации методов-этапов на уровне унаследованных классов.
# Краткая характеристика паттерна "Шаблонный метод"
Паттерн "Шаблонный метод" задает "скелет" алгоритма в методе, оставляя определение реализации некоторых шагов унаследованным классам. Эти классы могут переопределять некоторые части алгоритма без изменения его структуры.
